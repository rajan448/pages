<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Guide to Java Generics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the code blocks */
        pre {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            position: relative;
        }
        .code-header {
            background-color: #334155; /* slate-700 */
            padding: 0.5rem 1rem;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .code-title {
            font-size: 0.875rem;
            color: #cbd5e1; /* slate-300 */
            font-weight: 500;
        }
        .copy-btn {
            background-color: #475569; /* slate-600 */
            color: #e2e8f0; /* slate-200 */
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background-color 0.2s;
        }
        .copy-btn:hover {
            background-color: #64748b; /* slate-500 */
        }
        .tab-button.active {
            background-color: #2563eb; /* blue-600 */
            color: white;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        /* Style for inline code snippets */
        code:not(pre > code) {
            background-color: #334155; /* slate-700 */
            color: #f1f5f9; /* slate-100 */
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300 antialiased">

    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Interactive Guide to Java Generics</h1>
            <p class="text-lg text-slate-400">A single-page app to master generics, from basics to advanced concepts.</p>
        </header>

        <!-- Tab Navigation -->
        <div class="mb-8 overflow-x-auto">
            <div class="border-b border-slate-700">
                <nav class="-mb-px flex space-x-4" aria-label="Tabs" role="tablist">
                    <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="why-generics" role="tab" aria-controls="why-generics">
                        Why Generics?
                    </button>
                    <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="generic-classes" role="tab" aria-controls="generic-classes">
                        Generic Classes
                    </button>
                    <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="generic-methods" role="tab" aria-controls="generic-methods">
                        Generic Methods
                    </button>
                    <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="bounded-types" role="tab" aria-controls="bounded-types">
                        Bounded Types
                    </button>
                    <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="wildcards" role="tab" aria-controls="wildcards">
                        Wildcards & PECS
                    </button>
                     <button class="tab-button whitespace-nowrap py-4 px-3 border-b-2 border-transparent font-medium text-sm text-slate-400 hover:text-white hover:border-slate-400 focus:outline-none" data-tab="type-erasure" role="tab" aria-controls="type-erasure">
                        Type Erasure
                    </button>
                </nav>
            </div>
        </div>

        <!-- Tab Content -->
        <main>
            <!-- Tab 1: Why Generics? -->
            <div id="why-generics" class="tab-panel space-y-6" role="tabpanel">
                <h2 class="text-2xl font-bold text-white">1. Why Do We Need Generics?</h2>
                
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: The Problem-Solving Box</h3>
                    <p>Imagine you have a magic box that can hold anything: an apple, a book, a toy. The problem is, when you take something out, you don't know what it is. You might expect an apple but pull out a book. You have to guess, and if you guess wrong (try to take a bite out of a book), things go badly.</p>
                    <p class="mt-2">Generics are like putting a label on that box. If you label it <code>"Apple Box"</code>, the box will only accept apples. Now, when you reach in, you are 100% certain you're getting an apple. No more guesswork, no more painful surprises.</p>
                </div>

                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition</h3>
                    <p>Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. This allows for the creation of components that can work over different data types. The primary benefit is providing <strong class="text-white">compile-time type safety</strong>. Instead of using <code>Object</code> to handle multiple types (which requires explicit casting and is prone to runtime <code>ClassCastException</code>), generics allow the compiler to enforce type correctness at the time of writing code, not when it's running.</p>
                </div>

                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case: A Type-Unsafe List</h3>
                    <p class="mb-4">Let's see the problem in action with a simple <code>List</code> before generics were introduced in Java 5.</p>
                    
                    <div class="code-header">
                        <span class="code-title">Before Generics: Using Object and Casting</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>import java.util.ArrayList;
import java.util.List;

public class PreGenericsExample {
    public static void main(String[] args) {
        List list = new ArrayList(); // A raw list holds Objects
        list.add("Hello");
        list.add(123); // Oops, we added an Integer by mistake!

        // We expect a String, but the second element is an Integer.
        // The compiler doesn't know this!
        for (Object obj : list) {
            try {
                String str = (String) obj; // This will cause a runtime error
                System.out.println("Retrieved: " + str.toUpperCase());
            } catch (ClassCastException e) {
                System.err.println("Error: Could not cast " + obj.getClass().getName() + " to String!");
            }
        }
    }
}
// Output:
// Retrieved: HELLO
// Error: Could not cast java.lang.Integer to String!
</code></pre>

                    <p class="mt-6 mb-4">Now, let's fix this with generics. We "label" the list to only accept <code>String</code>s.</p>

                    <div class="code-header">
                        <span class="code-title">After Generics: Compile-Time Safety</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>import java.util.ArrayList;
import java.util.List;

public class PostGenericsExample {
    public static void main(String[] args) {
        // We specify the type parameter <String>
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        
        list.add("Hello");
        // list.add(123); // COMPILE ERROR! The compiler stops you here.
        
        // No casting needed, and it's guaranteed to be a String.
        for (String str : list) {
            System.out.println("Retrieved: " + str.toUpperCase());
        }
    }
}
// Output:
// Retrieved: HELLO
</code></pre>
                </div>
            </div>

            <!-- Tab 2: Generic Classes -->
            <div id="generic-classes" class="tab-panel space-y-6" role="tabpanel">
                <h2 class="text-2xl font-bold text-white">2. Generic Classes & Interfaces</h2>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: The Universal Container</h3>
                    <p>Imagine you're designing containers. Instead of making a specific "Juice Bottle," a "Milk Carton," and a "Water Flask," you design a universal "Liquid Container." This blueprint has a placeholder for "liquid type." When you manufacture one, you specify the liquid: "Liquid Container for Juice," "Liquid Container for Milk."</p>
                    <p class="mt-2">A generic class is that blueprint. <code>Box&lt;T&gt;</code> is the universal container design. <code>Box&lt;Apple&gt;</code> is a box made specifically for apples, and <code>Box&lt;Book&gt;</code> is a box made for books.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition</h3>
                    <p>A generic class or interface is declared with a type parameter section (e.g., <code>&lt;T&gt;</code>, <code>&lt;E&gt;</code>, <code>&lt;K, V&gt;</code>). This type parameter acts as a placeholder for a real type that will be specified when an instance of the class is created or the interface is implemented. <code>T</code> is a convention for Type, <code>E</code> for Element, <code>K</code> for Key, and <code>V</code> for Value.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case: A Reusable Box</h3>
                    <p class="mb-4">Let's create a simple <code>Box</code> class that can hold any object.</p>
                    <div class="code-header">
                        <span class="code-title">Generic Box&lt;T&gt; Class</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public class Box&lt;T&gt; {
    // T stands for "Type"
    private T content;

    public void set(T content) {
        this.content = content;
    }

    public T get() {
        return content;
    }
}</code></pre>

                    <p class="mt-6 mb-4">Now see how we can use this single <code>Box</code> class for different types without any casting.</p>
                    <div class="code-header">
                        <span class="code-title">Using the Generic Box</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public class BoxDemo {
    public static void main(String[] args) {
        // Create a Box for Integers
        Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();
        integerBox.set(10);
        // integerBox.set("hello"); // Compile Error!
        Integer intValue = integerBox.get();
        System.out.println("Integer value: " + intValue);

        // Create a Box for Strings
        Box&lt;String&gt; stringBox = new Box&lt;&gt;();
        stringBox.set("Hello World");
        String strValue = stringBox.get();
        System.out.println("String value: " + strValue);
    }
}
// Output:
// Integer value: 10
// String value: Hello World
</code></pre>
                </div>
            </div>
            
            <!-- Tab 3: Generic Methods -->
            <div id="generic-methods" class="tab-panel space-y-6" role="tabpanel">
                 <h2 class="text-2xl font-bold text-white">3. Generic Methods</h2>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: The Shape-Shifting Tool</h3>
                    <p>Imagine you have a magic wrench. This isn't a normal wrench that only fits one size of bolt. You can hand it any bolt—big, small, square, hexagonal—and it instantly changes shape to fit that specific bolt perfectly. It's a single tool that adapts to whatever you give it.</p>
                    <p class="mt-2">A generic method is like that wrench. It's a single method that can accept arguments of different types and work with them in a type-safe way. The method adapts its "internal type" based on the arguments you pass to it.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition</h3>
                    <p>Generic methods are methods that introduce their own type parameters. The scope of this type parameter is limited to the method where it is declared. This allows for type-safe operations on types that are specific to a single method call. The type parameter section is declared before the method's return type. You can have generic methods inside both generic and non-generic classes.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case: A Utility to Print Any Array</h3>
                    <p class="mb-4">Let's write a utility method that can print the elements of any type of array.</p>
                    <div class="code-header">
                        <span class="code-title">A Generic printArray Method</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public class GenericMethodUtil {
    // The &lt;E&gt; before void indicates this is a generic method.
    // E is the type parameter for this method only.
    public static &lt;E&gt; void printArray(E[] inputArray) {
        // Display array elements
        for (E element : inputArray) {
            System.out.printf("%s ", element);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        // Create arrays of different types
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

        System.out.println("Array integerArray contains:");
        printArray(intArray); // Pass an Integer array

        System.out.println("\nArray doubleArray contains:");
        printArray(doubleArray); // Pass a Double array

        System.out.println("\nArray characterArray contains:");
        printArray(charArray); // Pass a Character array
    }
}
// Output:
// Array integerArray contains:
// 1 2 3 4 5 
//
// Array doubleArray contains:
// 1.1 2.2 3.3 4.4 
//
// Array characterArray contains:
// H E L L O 
</code></pre>
                </div>
            </div>

            <!-- Tab 4: Bounded Types -->
            <div id="bounded-types" class="tab-panel space-y-6" role="tabpanel">
                <h2 class="text-2xl font-bold text-white">4. Bounded Type Parameters</h2>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: The "VIP Only" Club</h3>
                    <p>Imagine a club with a special room, the "Musicians' Lounge." The bouncer's rule is strict: only people who can play an instrument are allowed in. The bouncer doesn't care if you're a guitarist, a pianist, or a drummer—as long as you fulfill the "is a musician" requirement, you're in. Once inside, you can be asked to do musician things, like play a song.</p>
                    <p class="mt-2">Bounded types are that rule for your code. You can create a generic method or class that only works with types that have specific capabilities (i.e., they <code>extend</code> a class or <code>implement</code> an interface). For example, a method to find the biggest number only works on types that are <code>Number</code>s. A method to sort items only works on types that are <code>Comparable</code>.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition</h3>
                    <p>Bounded type parameters restrict the types that can be used as arguments for a generic type. This is crucial because it allows you to call methods defined in the bound. Without a bound, a generic type parameter like <code>T</code> is assumed to be just an <code>Object</code>, which has very few useful methods.</p>
                    <p class="mt-2">The syntax <code>&lt;T extends UpperBound&gt;</code> means that <code>T</code> can be any type that is a subtype of <code>UpperBound</code>, or <code>UpperBound</code> itself. Note that <code>extends</code> is used for both classes (to extend) and interfaces (to implement). You can have multiple bounds using the <code>&</code> operator, e.g., <code>&lt;T extends Number & Comparable&lt;T&gt;&gt;</code>.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case 1: A Method that Requires Number Operations</h3>
                    <p class="mb-4">Let's create a method that inspects a value but needs to call methods from the <code>Number</code> class.</p>
                    <div class="code-header">
                        <span class="code-title">Bounded Type Parameter with `extends Number`</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public class BoundedTypeExample {

    // This method accepts any type 'T' as long as it extends Number.
    // This allows us to safely call methods like .doubleValue() on the object.
    public static &lt;T extends Number&gt; void inspect(T number) {
        System.out.println("Class: " + number.getClass().getName());
        System.out.println("Value (as double): " + number.doubleValue());
    }

    public static void main(String[] args) {
        inspect(10); // OK, Integer extends Number
        inspect(15.5); // OK, Double extends Number
        // inspect("some text"); // COMPILE ERROR! String does not extend Number.
    }
}
</code></pre>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case 2: A Method that Requires Comparison</h3>
                    <p class="mb-4">Here's a more powerful example: a generic method to find the maximum of three values. This is only possible if we can guarantee the objects can be compared to each other, so we bound the type to the <code>Comparable</code> interface.</p>
                     <div class="code-header">
                        <span class="code-title">Bounded Type Parameter with `extends Comparable`</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public class MaxFinder {
    // We guarantee that T has a compareTo method.
    public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T x, T y, T z) {
        T max = x; // assume x is initially the largest
        
        if (y.compareTo(max) > 0) {
            max = y; // y is larger than max
        }
        if (z.compareTo(max) > 0) {
            max = z; // z is larger than max
        }
        return max;
    }

    public static void main(String[] args) {
        System.out.println("Max of 3, 4, 5 is " + findMax(3, 4, 5));
        System.out.println("Max of 6.6, 8.8, 7.7 is " + findMax(6.6, 8.8, 7.7));
        System.out.println("Max of 'apple', 'peach', 'orange' is " + findMax("apple", "peach", "orange"));
    }
}
// Output:
// Max of 3, 4, 5 is 5
// Max of 6.6, 8.8, 7.7 is 8.8
// Max of 'apple', 'peach', 'orange' is peach
</code></pre>
                </div>
            </div>

            <!-- Tab 5: Wildcards & PECS -->
            <div id="wildcards" class="tab-panel space-y-6" role="tabpanel">
                <h2 class="text-2xl font-bold text-white">5. Wildcards and the PECS Principle</h2>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: Flexible Food Baskets</h3>
                    <p>Imagine you have baskets for carrying food. In Java, <code>List&lt;Apple&gt;</code> is NOT a subtype of <code>List&lt;Fruit&gt;</code>, even though <code>Apple</code> is a <code>Fruit</code>. Wildcards fix this flexibility problem.</p>
                    <ul class="list-disc list-inside mt-2 space-y-2">
                        <li><code>List&lt;?&gt;</code> (A Basket of Unknown Food): You can look inside, but you can't add anything (except <code>null</code>). You don't know if it's a meat-only or fruit-only basket, so adding is unsafe.</li>
                        <li><code>List&lt;? extends Fruit&gt;</code> (A Basket of Fruit or its subtypes): This is a read-only basket. It might hold <code>Apple</code>s, <code>Banana</code>s, or just generic <code>Fruit</code>. You can <strong class="text-white">take things out</strong> and you're guaranteed to get a <code>Fruit</code>. But you can't put anything in, because you don't know if it's an <code>Apple</code>-only basket. This is a <strong class="text-emerald-400">Producer</strong>.</li>
                        <li><code>List&lt;? super Apple&gt;</code> (A Basket for Apples or its supertypes): This is a write-only basket. It's designed to hold <code>Apple</code>s, so you can safely <strong class="text-white">put an <code>Apple</code> into it</strong>. It could be a <code>List&lt;Apple&gt;</code>, a <code>List&lt;Fruit&gt;</code>, or even a <code>List&lt;Object&gt;</code>. When you take something out, you can only be sure it's an <code>Object</code>. This is a <strong class="text-amber-400">Consumer</strong>.</li>
                    </ul>
                </div>

                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition & PECS</h3>
                    <p>Wildcards (<code>?</code>) create flexible APIs by defining bounds for generic types in method signatures.</p>
                    <p class="mt-4 p-4 bg-slate-700 rounded-md"><strong class="text-sky-300">PECS: Producer Extends, Consumer Super.</strong></p>
                    <ul class="list-disc list-inside mt-2 space-y-2">
                        <li>"Use an <code>extends</code> wildcard (e.g., <code>&lt;? extends T&gt;</code>) when you only <strong class="text-emerald-400">get</strong> values out of a structure. It's a <strong class="text-emerald-400">Producer</strong>."</li>
                        <li>"Use a <code>super</code> wildcard (e.g., <code>&lt;? super T&gt;</code>) when you only <strong class="text-amber-400">put</strong> values into a structure. It's a <strong class="text-amber-400">Consumer</strong>."</li>
                        <li>If you need to both get and put, don't use a wildcard. Use an exact type like <code>List&lt;T&gt;</code>.</li>
                    </ul>
                </div>

                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Use Case: The `Collections.copy` Method</h3>
                    <p class="mb-4">The best example of PECS is the signature of Java's built-in <code>copy</code> method. Let's write our own version to understand it.</p>
                    <div class="code-header">
                        <span class="code-title">PECS in Action: A `copy` Method</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>import java.util.ArrayList;
import java.util.List;

public class PecsExample {

    // src is the Producer: We only read from it. So, we use 'extends'.
    // dest is the Consumer: We only write to it. So, we use 'super'.
    public static &lt;T&gt; void copy(List&lt;? extends T&gt; src, List&lt;? super T&gt; dest) {
        for (T item : src) {
            dest.add(item);
        }
    }

    public static void main(String[] args) {
        // Example: Copy a list of Integers into a list of Numbers
        List&lt;Integer&gt; integers = List.of(1, 2, 3);
        List&lt;Number&gt; numbers = new ArrayList&lt;&gt;();

        // This works because:
        // - 'integers' can be a producer of Number (? extends Number)
        // - 'numbers' can be a consumer of Integer (? super Integer)
        copy(integers, numbers);
        
        System.out.println("Source Integers: " + integers);
        System.out.println("Destination Numbers: " + numbers);

        // List&lt;Number&gt; src = List.of(1.0, 2.0);
        // List&lt;Integer&gt; dest = new ArrayList&lt;&gt;();
        // copy(src, dest); // COMPILE ERROR! You can't put a Number into a list of Integers.
    }
}
</code></pre>
                </div>
            </div>
            
            <!-- Tab 6: Type Erasure -->
            <div id="type-erasure" class="tab-panel space-y-6" role="tabpanel">
                <h2 class="text-2xl font-bold text-white">6. Type Erasure</h2>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">For Dummies: The Secret Recipe</h3>
                    <p>You bake a beautiful cake using a special "Fruit Cake" recipe (e.g., <code>List&lt;Fruit&gt;</code>). The recipe ensures you only add fruit. Once the cake is baked and out of the oven (compiled to bytecode), it's just a "Cake" (a raw <code>List</code>). Someone looking at the final cake can't see the original "Fruit Cake" recipe; the specific type information is gone.</p>
                    <p class="mt-2">However, the baker (the compiler) was very clever. Wherever you retrieve a slice, the baker secretly included an instruction to "check if this slice is a fruit" (a cast). So, while the type information seems to be gone, the safety is still enforced by these hidden instructions. This is why you can't ask the finished cake "Were you made with the Fruit Cake recipe?" (<code>instanceof List&lt;Fruit&gt;</code>) at runtime—it doesn't know.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Technical Definition</h3>
                    <p>Type erasure is the process where the Java compiler removes generic type information to ensure backward compatibility. At compile time, the compiler uses the generic type information to perform type checks, but then erases it from the generated bytecode.</p>
                    <ul class="list-disc list-inside mt-2 space-y-2">
                        <li>Each type parameter (like <code>T</code>) is replaced by its first bound, or by <code>Object</code> if it has no bound. <code>&lt;T extends Number&gt;</code> becomes <code>Number</code>. <code>&lt;T&gt;</code> becomes <code>Object</code>.</li>
                        <li>The compiler inserts explicit casts where necessary to maintain type safety.</li>
                    </ul>
                    <p class="mt-4">This means that at runtime, the JVM has no knowledge of generic types like <code>List&lt;String&gt;</code>; it only sees a raw <code>List</code>.</p>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">What the Compiler Actually Does</h3>
                    <p class="mb-4">Let's see what your generic code looks like after the compiler performs type erasure.</p>
                    <div class="code-header">
                        <span class="code-title">Your Generic Code</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>public &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T x, T y) {
    return x.compareTo(y) > 0 ? x : y;
}

String max = findMax("a", "b");
</code></pre>
                    <p class="mt-6 mb-4">This is what the compiler effectively generates in the bytecode:</p>
                     <div class="code-header">
                        <span class="code-title">Code After Type Erasure</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre><code>// The type parameter 'T' is replaced by its bound, 'Comparable'.
public Comparable findMax(Comparable x, Comparable y) {
    return x.compareTo(y) > 0 ? x : y;
}

// The compiler inserts a cast to maintain type safety.
String max = (String) findMax("a", "b");
</code></pre>
                </div>
                <div class="bg-slate-800 p-6 rounded-lg">
                    <h3 class="text-xl font-semibold text-sky-400 mb-3">Implications and Limitations</h3>
                    <p class="mb-4">Because generic type information is erased, there are several restrictions:</p>
                    <ul class="list-disc list-inside mt-2 space-y-3">
                        <li><b>Cannot create instances of type parameters:</b> You can't do <code>new T()</code> because at runtime, <code>T</code> is gone. The compiler wouldn't know which constructor to call.</li>
                        <li><b>Cannot create arrays of generic types:</b> <code>T[] array = new T[10];</code> is illegal. This is because arrays store type information at runtime, which would conflict with the erased type <code>T</code>, breaking type safety.</li>
                        <li><b>Cannot use <code>instanceof</code> with generic types:</b> A check like <code>if (list instanceof List&lt;String&gt;)</code> is forbidden because the JVM can't see the <code>&lt;String&gt;</code> part at runtime. You can only check <code>if (list instanceof List)</code>.</li>
                        <li><b>Cannot have static fields of a type parameter:</b> A field like <code>private static T staticField;</code> is not allowed. A static field is shared by all instances of a class, but if <code>T</code> could be different for each instance (e.g., <code>MyClass&lt;String&gt;</code> and <code>MyClass&lt;Integer&gt;</code>), it would be impossible to have a single static field that works for both.</li>
                         <li><b>Cannot overload a method based on generic types:</b> A class cannot have two methods like <code>void print(List&lt;String&gt; list)</code> and <code>void print(List&lt;Integer&gt; list)</code> because after erasure, both would have the same signature: <code>void print(List list)</code>.</li>
                    </ul>
                </div>
            </div>

        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const tabs = document.querySelectorAll('.tab-button');
            const panels = document.querySelectorAll('.tab-panel');
            const copyButtons = document.querySelectorAll('.copy-btn');

            // Function to switch tabs
            const switchTab = (tabButton) => {
                const tabId = tabButton.dataset.tab;

                // Deactivate all tabs and panels
                tabs.forEach(t => {
                    t.classList.remove('active', 'border-blue-600', 'text-white');
                    t.setAttribute('aria-selected', 'false');
                });
                panels.forEach(p => p.classList.remove('active'));

                // Activate the clicked tab and corresponding panel
                tabButton.classList.add('active', 'border-blue-600', 'text-white');
                tabButton.setAttribute('aria-selected', 'true');
                document.getElementById(tabId).classList.add('active');
            };

            // Add click listener to tab buttons
            tabs.forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab));
            });

            // Set the first tab as active by default
            if (tabs.length > 0) {
                switchTab(tabs[0]);
            }
            
            // Add click listener to copy buttons
            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const pre = button.closest('.code-header').nextElementSibling;
                    const code = pre.querySelector('code');
                    
                    // Create a temporary textarea to hold the text
                    const textArea = document.createElement('textarea');
                    textArea.value = code.textContent;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        button.textContent = 'Copied!';
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        button.textContent = 'Error';
                    }
                    document.body.removeChild(textArea);

                    // Revert button text after a delay
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>
